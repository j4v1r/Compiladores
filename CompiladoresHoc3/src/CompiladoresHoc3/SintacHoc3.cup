import java_cup.runtime.*;
import java.io.FileReader;

class AnalizadorSintactico;

parser code{:
    formHoc3 frmInterfaz; /*= new FrmPricipal3()*/
    
    public void report_error(String mensaje,Object info){
        StringBuilder m = new StringBuilder("Error");
        if(info instanceof java_cup.runtime.Symbol){
            java_cup.runtime.Symbol s = (java_cup.runtime.Symbol) info;
            if(s.left >=0){
                m.append(" en la linea " + (s.left+1));
                if(s.right>=0)
                    m.append(", columna " + (s.right+1));
            }
        }
        m.append(" : " + mensaje);
        System.err.println(m);
    }   

    public void report_fatal_error(String message, Object info){
        report_error(message, info);
        System.exit(1);
    }
:}

terminal SEMIC;
terminal OpSuma,OpResta, OpPred, OpDiv, OpAsig ,OpPotencia;
terminal ParIzq, ParDer;
terminal Float NUM;
terminal SymbolHoc VAR;
terminal SymbolHoc CONST_PRED; /* PI , E, PHI , RAD, etc*/
terminal SymbolHoc BLTIN; /* sin,cos,atan,etc*/
terminal MENOSUNARIO;

non terminal list;
non terminal Float asgn, expr;

precedence right OpAsing;
precedence left OpSuma, OpResta;
precedence left OpProd, OpDiv;
prededence left MENOSUNARIO;
precedence right OpPotencia;

list    ::= expr:vaiExpr SEMIC      {:
                                            frmInterfaz.txtResultSintactico.append(Float.toString(valExpr) + "\n");
                                    :}
        | list expr:valExpr SEMIC   {:
                                            frmInterfaz.txtResultSintactico.append(Float.toString(valExpr) + "\n");
                                    :}
        ;
asgn    ::= VAR:v OpAsin expr:ind1  {:
                                        v.val = valExpr;
                                        RESULT = valExpr;
                                    :}
        ;
expr    ::= NUM:valNum                      {:  RESULT = valNum; :}
        |   VAR:refVar                      {:  RESULT = refVar.val; :}
        |   CONST_PRED:refConstPredef       {:  RESULT = refConstPredef.val; :}
        |   asgn:valAsign                   {:  RESULT = valAsign;   :}
        |   expr:vall OpSuma expr:val2          {:  RESULT = val1 + val2;   :}
        |   expr:vall OpResta expr:val2         {:  RESULT = val1 - val2;   :}
        |   expr:vall OpProd expr:val2          {:  RESULT = val1 * val2;   :}
        |   expr:vall OpDiv expr:val2           {:  RESULT = val1 / val2;   :}
        |   ParIzq expr:val1 ParDer             {:  RESULT = val1;  :}
        |   BLTIN:v ParIzq expr:val1 ParDer     {:
                                                    switch(v.FuncPredef)
                                                    {
                                                        case SIN :
                                                                RESULT = (float)Match.sin((double)val1);
                                                                BREAK;
                                                        case COS :
                                                                RESULT = (float)Match.oos((double)val1);
                                                                BREAK;    
                                                        case ATAN :
                                                                RESULT = (float)Match.atan((double)val1);
                                                                BREAK;
                                                        case LOG :
                                                                RESULT = (float)Match.log((double)val1);
                                                                BREAK;
                                                        case LOG10 :
                                                                RESULT = (float)Match.log10((double)val1);
                                                                BREAK;
                                                        case EXP :
                                                                RESULT = (float)Match.exp((double)val1);
                                                                BREAK;
                                                        case SQRT :
                                                                RESULT = (float)Match.sqrt((double)val1);
                                                                BREAK;
                                                        case INT :
                                                                RESULT = (float)Match.floor((double)val1);
                                                                BREAK;
                                                        case ABS :
                                                                RESULT = (float)Match.abs((double)val1);
                                                                BREAK;
                                                                
                                                    }

                                                    :}
    |   OpResta expr:val1   {:  RESULT= -val1;  :}  %prec MENOSUNARIO
    |   expr:base OpPotencia expre:exponente    {:
                                            RESULT = (float)Math.pow((double) base,(double) exponente)
                                                :}
    ;